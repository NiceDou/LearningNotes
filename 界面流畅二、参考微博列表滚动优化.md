## 优化一、异步子线程frame计算并缓存


### VC中加载到实体数据之后，交给缓存异步线程计算frame，回调主线程刷新UI

```objc
#import "DemoTableViewController.h"
#import "DemoTableViewCell.h"

@interface DemoTableViewController ()

@end

@implementation DemoTableViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    //1. 准备 Model Array
    NSMutableArray *sections = [[NSMutableArray alloc] initWithCapacity:5];
    for (int i = 0; i < 5; i++) {
        NSMutableArray *rows = [[NSMutableArray alloc] initWithCapacity:5];
        for (int j = 0; j < 5; j++) {
            DemoTableViewCellModel *model = [[DemoTableViewCellModel alloc] init];
            model.title = @"我是title";
            model.name = @"我是name";
            [rows addObject:model];
        }
        [sections addObject:rows];
    }
    
    //2. 将 Model Array 交给 Cache进行计算、缓存，完成后回调主线程刷新UI
    [[DemoTableViewCellFrameCache sharedInstance] computeCellFrameWithModelArray:sections
                                                                 completionBlock:^{
        dispatch_async(dispatch_get_main_queue(), ^{
            [self.tableView reloadData];
        });
    }];
}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
}

#pragma mark - Table view data source

- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
    return [DemoTableViewCellFrameCache sharedInstance].frameModelArray.count;
}

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    NSArray *rows = [[DemoTableViewCellFrameCache sharedInstance].frameModelArray objectAtIndex:section];
    return rows.count;
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"haha" forIndexPath:indexPath];
    
    return cell;
}

- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath {
    
    //1. 从缓存取出indexpath对应的frame
    NSArray *rows = [[DemoTableViewCellFrameCache sharedInstance].frameModelArray objectAtIndex:indexPath.section];
    DemoTableViewCellFrame *frame = [rows objectAtIndex:indexPath.row];
    
    //2. 返回frame预先计算完毕的数据
    return frame.cellHeight;
    
}

@end
```

### `DemoTableViewCellFrameCache`负责计算实体数组中每一个实体在cell上显示的frame、cell总高度，并使用对应的NSIndexPath进行缓存

```objc
@interface DemoTableViewCellFrameCache : NSObject
@property (nonatomic, strong, readonly) NSMutableArray *frameModelArray;

+ (instancetype)sharedInstance;
- (void)computeCellFrameWithModelArray:(NSArray *)modelArray completionBlock:(void(^)(void))block;
@end
@implementation DemoTableViewCellFrameCache

+ (instancetype)sharedInstance {
    static DemoTableViewCellFrameCache *_cache = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _cache = [[DemoTableViewCellFrameCache alloc] init];
    });
    return _cache;
}

- (void)computeCellFrameWithModelArray:(NSArray *)modelArray completionBlock:(void(^)(void))block {
    
    // 先清除掉之前缓存的frame array
    if (_frameModelArray && _frameModelArray.count > 0) {
        //1.
        NSArray *holder = [[NSArray alloc] initWithArray:_frameModelArray];
        //2.
        _frameModelArray = nil;
        //3.
        dispatch_async(dispatch_get_global_queue(0, 0), ^{
            [holder count];
        });
    }
    
    // 子线程计算frame，并缓存
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        
        _frameModelArray = [[NSMutableArray alloc] initWithCapacity:modelArray.count];
        
        // sections
        for (int section = 0; section < modelArray.count; section++) {
            // rows
            
            NSMutableArray *rowsFrameArray = [[NSMutableArray alloc] initWithCapacity:modelArray.count];
            NSArray *rows = [modelArray objectAtIndex:section];
            
            for (int row = 0; row < rows.count; row++) {
                
                // 取出indexpath对应的model
                DemoTableViewCellModel *model = [rows objectAtIndex:row];
                
                // 成完成Frame的计算
                DemoTableViewCellFrame *frame = [[DemoTableViewCellFrame alloc] initWithModel:model];
                
                [rowsFrameArray addObject:frame];
            }
            
            [_frameModelArray addObject:rowsFrameArray];
        }
    });
}

@end
```

### DemoTableViewCellFrame 计算cell的frame代码

```objc
@interface DemoTableViewCellFrame : NSObject
@property (nonatomic, strong, readonly) DemoTableViewCellModel *model;//cell显示的数据
@property (nonatomic, assign, readonly) CGFloat cellHeight;//计算后的cell的总高度
@property (nonatomic, assign, readonly) CGRect titleLabelFrame;//计算算后的sunbiew1.frame
@property (nonatomic, assign, readonly) CGRect nameLabelFrame;//计算算后的sunbiew2.frame
@end
@implementation DemoTableViewCellFrame

- (instancetype)initWithModel:(DemoTableViewCellModel *)model {
    if (self = [super init]) {
        /**
         *  计算cell的总高度、cell.subviews.frame
         */
        
        //1. 假设计算frame
        _titleLabelFrame = CGRectMake(0, 0, 0, 0);
        
        //2. 假设计算frame
        _nameLabelFrame = CGRectMake(0, 0, 0, 0);
        
        //3. 假设计算cell高度
        _cellHeight = CGRectGetMaxY(_nameLabelFrame) + 20.f;
    }
    return self;
}
@end
```

### cell显示数据的内部实体

```objc
@interface DemoTableViewCellModel : NSObject
@property (nonatomic, copy) NSString *title;
@property (nonatomic, copy) NSString *name;
@end
@implementation DemoTableViewCellModel
@end
```

### cell

```objc
@interface DemoTableViewCell : UITableViewCell
@property (nonatomic, strong) UILabel *titleLabel;
@property (nonatomic, strong) UILabel *nameLabel;

- (void)layoutSubviewsWithFrame:(DemoTableViewCellFrame *)frame;
@end
@implementation DemoTableViewCell {
    DemoTableViewCellFrame *_frame;
}

- (instancetype)initWithFrame:(CGRect)frame {
    if (self = [super initWithFrame:frame]) {
        [self initSubviews];
    }
    return self;
}

- (void)initSubviews {
    //.......
}

- (void)layoutSubviewsWithFrame:(DemoTableViewCellFrame *)frame {
    //1.
    _frame = frame;
    
    //2.
    _titleLabel.text = _frame.model.title;
    _nameLabel.text = _frame.model.name;
    
    //3.
    [self setNeedsLayout];
}

#pragma mark - layout subveiws frame

- (void)layoutSubviews {
    [super layoutSubviews];
    
    _titleLabel.frame = _frame.titleLabelFrame;
    _nameLabel.frame = _frame.nameLabelFrame;
}

@end
```


可以参考`FDTemplateLayoutCell`的缓存实现。

## 优化二、对CALayer设置：缩放、圆角、边框、遮罩等。代替为：在后台子线程使用CoreGraphics预先进行图形的绘制处理完成。而CALayer只是负责拿到处理后的图形进行显示即可。

### 给UIImage添加分类方法，直接对原始图形进行处理

```objc
- (UIImage *)imageScaledToSize:(CGSize)size boundingSize:(CGSize)boundingSize cornerRadius:(CGFloat)cornerRadius borderWidth:(CGFloat)borderWidth borderColor:(UIColor *)borderColor
{
    //create drawing context
    UIGraphicsBeginImageContextWithOptions(size, NO, 0.0f);

    //需要将可视区域画到图片的中心
    CGFloat originX = (size.width-boundingSize.width)/2;
    originX = originX < 0 ? 0 : originX;

    CGFloat originY = (size.height-boundingSize.height)/2;
    originY = originY < 0 ? 0 : originY;

    [borderColor setStroke];
    UIBezierPath *bezierPath = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(originX, originY, boundingSize.width, boundingSize.height) cornerRadius:cornerRadius];
    [bezierPath setLineWidth:borderWidth];
    [bezierPath stroke];
    [bezierPath addClip];

    //draw
    [self drawInRect:CGRectMake(0.0f, 0.0f, size.width, size.height)];

    //capture resultant image
    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();

    return image;
}
```

### 然后将渲染后的圆角边框等效果的图形缓存在内存中

> 记得要缓存处理成圆角的image，不然频繁的绘制也会造成卡顿。

写一个类似SDImageCache的库，进行图像的内存缓存。

### 在需要圆角时调用如下

```objc
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

	//1. 子线程完成图形的特效处理
    UIImage *img = [[UIImage imageNamed:@"image.png"] drawCircleImage];
    
    //2. 主线程完成UI的图形设置
    dispatch_async(dispatch_get_main_queue(), ^{
        imageView.image = img;
    });
});
```

## 优化三、异步子线程完成图形绘制、文本绘制

自定义一个UILabel，内部使用`CoreText+子线程`将文字渲染成图像，再设置给UIImageView，这里可以直接使用一个CALayer.contents属性。

```objc
@implementation VVeboLabel

- (id)initWithFrame:(CGRect)frame {
    self = [super initWithFrame:frame];
    if (self) {
    	labelImageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, -5, frame.size.width, frame.size.height+10)];
        labelImageView.contentMode = UIViewContentModeScaleAspectFit;
        labelImageView.tag = NSIntegerMin;
        labelImageView.clipsToBounds = YES;
        [self addSubview:labelImageView];
        
        highlightImageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, -5, frame.size.width, frame.size.height+10)];
        highlightImageView.contentMode = UIViewContentModeScaleAspectFit;
        highlightImageView.tag = NSIntegerMin;
        highlightImageView.clipsToBounds = YES;
        highlightImageView.backgroundColor = [UIColor clearColor];
        [self addSubview:highlightImageView];

        .....
    }
    return self;
}

// 将要显示的文本内容使用CoreText绘制，并在一个异步子线程上完成
- (void)setText:(NSString *)text{
	........

	dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

		//1. 开起一个绘图画布
		UIGraphicsBeginImageContextWithOptions(size, ![self.backgroundColor isEqual:[UIColor clearColor]], 0);
        CGContextRef context = UIGraphicsGetCurrentContext();
        if (context==NULL) {
            return;
        }

        //2. 画布基本设置
        if (![self.backgroundColor isEqual:[UIColor clearColor]]) {
            [self.backgroundColor set];
            CGContextFillRect(context, CGRectMake(0, 0, size.width, size.height));
        }
        CGContextSetTextMatrix(context,CGAffineTransformIdentity);
        CGContextTranslateCTM(context,0,size.height);
        CGContextScaleCTM(context,1.0,-1.0);

        //3. CoreText文本渲染设置
        CGFloat minimumLineHeight = self.font.pointSize,maximumLineHeight = minimumLineHeight, linespace = self.lineSpace;
        CTFontRef font = CTFontCreateWithName((__bridge CFStringRef)self.font.fontName, self.font.pointSize,NULL);
        CTLineBreakMode lineBreakMode = kCTLineBreakByWordWrapping;
        CTTextAlignment alignment = CTTextAlignmentFromUITextAlignment(self.textAlignment);
        CTParagraphStyleRef style = CTParagraphStyleCreate((CTParagraphStyleSetting[6]){
            {kCTParagraphStyleSpecifierAlignment, sizeof(alignment), &alignment},
            {kCTParagraphStyleSpecifierMinimumLineHeight,sizeof(minimumLineHeight),&minimumLineHeight},
            {kCTParagraphStyleSpecifierMaximumLineHeight,sizeof(maximumLineHeight),&maximumLineHeight},
            {kCTParagraphStyleSpecifierMaximumLineSpacing, sizeof(linespace), &linespace},
            {kCTParagraphStyleSpecifierMinimumLineSpacing, sizeof(linespace), &linespace},
            {kCTParagraphStyleSpecifierLineBreakMode,sizeof(CTLineBreakMode),&lineBreakMode}
        },6);

        //4. 根据 3. 得到的CoreText文本绘制设置，创建属性字典
        NSDictionary* attributes = [NSDictionary dictionaryWithObjectsAndKeys:(__bridge id)font,(NSString*)kCTFontAttributeName,
                                    textColor.CGColor,kCTForegroundColorAttributeName,
                                    style,kCTParagraphStyleAttributeName,
                                    nil];

        //5. 使用属性字典，构建 富文本字符串 
        NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:text attributes:attributes];

        //6. NSMutableAttributedString 转换成 CFAttributedStringRef
        CFAttributedStringRef attributedString = (__bridge CFAttributedStringRef)[self highlightText:attributedStr];

        //7. 将富文本绘制到画布区域
        CGRect rect = CGRectMake(0, 5,(size.width),(size.height-5));
        [self drawFramesetter:framesetter
                 attributedString:attributedStr
                        textRange:CFRangeMake(0, text.length)
                           inRect:rect
                          context:context];

        //8. 从画布中得到渲染完毕的图像
        UIImage *screenShotimage = UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();

        //9. 将渲染得到的图像设置给内部的image view
        dispatch_async(dispatch_get_main_queue(), ^{

        		//9.1 释放系统对象
                CFRelease(font);
                CFRelease(framesetter);

                //9.2 
                labelImageView.image = screenShotimage;

        });
    }
}
```

对于`图像`的绘制:

```objc
[[UIImage imageNamed:@"t_repost.png"] drawInRect:CGRectMake(x-5, 11+countRect.origin.y, 10, 9)
                                                       blendMode:kCGBlendModeNormal
                                                           alpha:alpha];
```

对于`纯文本`使用CoreText绘制的大概使用过程:

```objc
- (void)drawFramesetter:(CTFramesetterRef)framesetter
       attributedString:(NSAttributedString *)attributedString
              textRange:(CFRange)textRange
                 inRect:(CGRect)rect
                context:(CGContextRef)c 
{
 	/**
 	 *	一、CTFramesetterRef 容器包含
 	 * (1) CTFrame 某一页显示的文字
 	 * (2) CTLine	 某一行显示的文字
 	 * (3) CTRun	某一行中的某一个小块（显示文字或一个图片）
	 *
 	 *	二、CTParagraphStyle 段落样式设置
	 *	typedef CF_ENUM(uint32_t, CTParagraphStyleSpecifier) {
	 *		对齐方式,
	 *	 	首行缩进,
	 *	  	段尾缩进 ,
	 *	   换行模式 ,
	 *	   多行高 ,
	 *	   行距 ,
	 *	   段落间距,
	 *	   行距调整 ,
	 *	   .....等等
	 * };
	 *
 	 *	三、文字绘制
 	 * - CTRunDraw(CTRunRef run, CGContextRef context, CFRange range)
 	 * - CTLineDraw(CTLineRef line, CGContextRef context)
 	 * - CTFrameDraw(CTFrameRef frame, CGContextRef context);
 	 * 
 	 * 四、CTRunDelegateRef 回调获取某一个块显示的内容
 	 * 比如、显示emoji时，需要回调获取显示的内容：
 	 * (1) 图片
 	 * (2) 宽度
 	 * (3) 高度
 	 */               
}
```

上面通过使用`CoreGraphics`创建一个绘图上下文来完成的，这会开起CPU的离屏渲染，增加CPU进行图形渲染的浪费。其实可以通过`CATextLayer`来完成`纯文本`的绘制，会直接使用GPU进行高性能渲染。

```objc
#import "LayerLabel.h"
#import <QuartzCore/QuartzCore.h>

@implementation LayerLabel

//1. 
+ (Class)layerClass
{
  //this makes our label create a CATextLayer //instead of a regular CALayer for its backing layer
  return [CATextLayer class];
}

//2.
- (CATextLayer *)textLayer
{
	// 直接将系统创建的self.lay强转
  return (CATextLayer *)self.layer;
}

- (void)setUp
{
  //set defaults from UILabel settings
  self.text = self.text;
  self.textColor = self.textColor;
  self.font = self.font;

  //we should really derive these from the UILabel settings too
  //but that's complicated, so for now we'll just hard-code them
  [self textLayer].alignmentMode = kCAAlignmentJustified;
  ￼
  [self textLayer].wrapped = YES;
  [self.layer display];
}

- (id)initWithFrame:(CGRect)frame
{
  //called when creating label programmatically
  if (self = [super initWithFrame:frame]) {
    [self setUp];
  }
  return self;
}

- (void)awakeFromNib
{
  //called when creating label using Interface Builder
  [self setUp];
}

- (void)setText:(NSString *)text
{
  super.text = text;
  //set layer text
  [self textLayer].string = text;
}

- (void)setTextColor:(UIColor *)textColor
{
  super.textColor = textColor;
  //set layer text color
  [self textLayer].foregroundColor = textColor.CGColor;
}

- (void)setFont:(UIFont *)font
{
  super.font = font;
  //set layer font
  CFStringRef fontName = (__bridge CFStringRef)font.fontName;
  CGFontRef fontRef = CGFontCreateWithFontName(fontName);
  [self textLayer].font = fontRef;
  [self textLayer].fontSize = font.pointSize;
  ￼
  CGFontRelease(fontRef);
}

@end
```

可以看到使用`CATextLayer`的代码相比之前的代码，减少了很多的`CoreText`操作的代码。

我们基本上只需要构建好 `NSString 或 NSMutableString`，然后只需要交给`CATextLayer`渲染即可。

但是，注意`CATextLayer`只适用于`纯文本`的高性能渲染，如果`既有图像、又有文字`可能就需要像最上面的代码，使用`CoreGraphics+CoreText`的办法了：

- (1) CoreGraphics 负责开起画布，完成图像的绘制
- (2) CoreText 负责文本内容的绘制
                
## 优化四、列表快速滚动时，将快速滚动过的绘制任务取消绘制


## 优化五、列表快速滚动时，计算当松开手指后，列表将会停止到的cell位置，绘制这个cell以及附近的几个cell，而忽略其他滚动中的cell绘制

## 优化六、在大量的异步子线程完成绘制代码时，并打队列可能会无限制创建新的子线程完成绘制代码

通过自定义一个`串行的 dispatch_queue_t`的内存缓存池来完成:

- (1) serial dispatch queue 包装了永远复用一个子线程
- (2) 使用`QOS`的多种优先级，分别缓存queue，可以在不同的优先级下的queue做不同重要的绘制代码
- (3) 每一个QOS级别下，缓存的queue个数=`CPU激活的核心数`，这样可以保证某一个QOS下的线程可以跑满CPU


queue的缓存池结构如下:

```
- (1) QOS_CLASS_USER_INTERACTIVE Dispatch Context 对象
	- 缓存的dispatch_queue_t 实例1
	- 缓存的dispatch_queue_t 实例1
	- ....
	- 缓存的dispatch_queue_t 实例n
	
- (2) QOS_CLASS_USER_INITIATED Dispatch Context 对象
	- 缓存的dispatch_queue_t 实例1
	- 缓存的dispatch_queue_t 实例1
	- ....
	- 缓存的dispatch_queue_t 实例n
	
- (3) QOS_CLASS_DEFAULT Dispatch Context 对象
	- 缓存的dispatch_queue_t 实例1
	- 缓存的dispatch_queue_t 实例1
	- ....
	- 缓存的dispatch_queue_t 实例n
	
- (4) QOS_CLASS_UTILITY Dispatch Context 对象
	- 缓存的dispatch_queue_t 实例1
	- 缓存的dispatch_queue_t 实例1
	- ....
	- 缓存的dispatch_queue_t 实例n
	
- (5) QOS_CLASS_BACKGROUND Dispatch Context 对象
	- 缓存的dispatch_queue_t 实例1
	- 缓存的dispatch_queue_t 实例1
	- ....
	- 缓存的dispatch_queue_t 实例n
```


这样就可以将`图像解码、对象释放、异步绘制`等，都按`优先级`放入不同的全局的 serial queue 中执行，这样尽量避免了过多线程导致的性能问题。


## 优化七、直接使用CALayer.contents 代替 UIImageView 显示图像

## 优化八、ASDK原理